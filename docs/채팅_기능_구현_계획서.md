# 매칭 성공 시 채팅방 생성 및 채팅 기능 구현 계획서

## 📋 목차
1. [개요](#개요)
2. [시스템 아키텍처](#시스템-아키텍처)
3. [데이터베이스 설계](#데이터베이스-설계)
4. [API 명세](#api-명세)
5. [다국어 및 번역 기능](#다국어-및-번역-기능)
6. [WebSocket 설정](#websocket-설정)
7. [구현 단계](#구현-단계)
8. [기술 스택](#기술-스택)
9. [보안 고려사항](#보안-고려사항)
10. [예외 처리](#예외-처리)
11. [테스트 계획](#테스트-계획)
12. [다국어 채팅 상세 설계](#다국어-채팅-상세-설계)
13. [메시지 보관 정책 및 비용 분석](#메시지-보관-정책-및-비용-분석)
14. [추가 고려사항](#추가-고려사항)

---

## 개요

### 목표
- 매칭 상태가 `ACCEPTED`가 되면 자동으로 채팅방 생성
- 실시간 양방향 채팅 기능 제공
- **다국어 채팅 지원**: 일본 여성은 일본어, 한국 남성은 한국어로 채팅
- **고속 자동 번역 기능**: Google Cloud Translation API를 활용한 빠른 번역 (100~300ms)
- **하이브리드 전송 방식**: 원문 즉시 전송으로 사용자 체감 지연 최소화
- **번역 캐싱**: 자주 사용되는 표현 즉시 반환 (<10ms)
- 채팅방 목록 조회 및 메시지 히스토리 조회
- 읽지 않은 메시지 개수 표시
- 푸시 알림 연동

### 배경
현재 시스템에서는 매칭이 성공(`MatchingStatus.ACCEPTED`)되면 채팅을 시작할 수 있다고 명시되어 있으나, 실제 채팅 기능은 구현되지 않은 상태입니다. 본 계획서는 매칭 성공 시 자동으로 채팅방을 생성하고 실시간 채팅 기능을 제공하는 것을 목표로 합니다.

### 다국어 채팅 요구사항
- **일본 여성 (JAPANESE_FEMALE)**: 일본어로 메시지 작성 및 전송
- **한국 남성 (KOREAN_MALE)**: 한국어로 메시지 작성 및 전송
- **자동 번역**: 상대방이 보낸 메시지를 자신의 언어로 자동 번역하여 표시
- **원문 보존**: 원본 메시지와 번역된 메시지를 모두 저장하여 추후 검색 및 감사 가능

---

## 시스템 아키텍처

### 전체 흐름도

```
[매칭 수락] 
    ↓
[MatchingStatus.ACCEPTED]
    ↓
[채팅방 자동 생성]
    ↓
[WebSocket 연결]
    ↓
[실시간 메시지 송수신]
```

### 컴포넌트 구조

```
┌─────────────────────────────────────────┐
│         Client (Mobile App)             │
└─────────────────────────────────────────┘
                    ↕ HTTP/WebSocket
┌─────────────────────────────────────────┐
│         Spring Boot Backend             │
│  ┌──────────────┐  ┌──────────────┐    │
│  │ REST API     │  │ WebSocket    │    │
│  │ Controller   │  │ Controller   │    │
│  └──────────────┘  └──────────────┘    │
│  ┌──────────────┐  ┌──────────────┐    │
│  │ Chat Service │  │ Matching     │    │
│  │              │  │ Service      │    │
│  └──────────────┘  └──────────────┘    │
│  ┌──────────────────────────────────┐  │
│  │      JPA Repository              │  │
│  └──────────────────────────────────┘  │
└─────────────────────────────────────────┘
                    ↕
┌─────────────────────────────────────────┐
│         MySQL Database                  │
│  - chat_room                            │
│  - chat_message                         │
│  - matching                             │
└─────────────────────────────────────────┘
```

---

## 데이터베이스 설계

### ERD

```
┌─────────────┐         ┌──────────────┐         ┌─────────────┐
│   Member    │         │  ChatRoom    │         │   Matching   │
├─────────────┤         ├──────────────┤         ├─────────────┤
│ id (PK)     │         │ id (PK)      │         │ id (PK)      │
│ name        │◄──┐     │ matching_id  │◄────────│ female_id    │
│ email       │   │     │  (FK, UNIQUE)│         │ male_id      │
│ ...         │   │     │ created_at   │         │ status       │
└─────────────┘   │     │ updated_at   │         │ ...          │
                  │     │ deleted_at   │         └─────────────┘
                  │     └──────────────┘
                  │              │
                  │              │
                  │     ┌──────────────┐
                  └────►│ ChatMessage   │
                        ├──────────────┤
                        │ id (PK)      │
                        │ chat_room_id │
                        │ sender_id    │
                        │ content      │
                        │ language     │
                        │ translated_content │
                        │ message_type │
                        │ is_read      │
                        │ created_at   │
                        └──────────────┘
```

### 테이블 상세 설계

#### 1. chat_room 테이블

| 컬럼명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| id | BIGINT | PK, AUTO_INCREMENT | 채팅방 ID |
| matching_id | BIGINT | FK, UNIQUE, NOT NULL | 매칭 ID (1:1 관계) |
| created_at | DATETIME | NOT NULL | 생성일시 |
| updated_at | DATETIME | NOT NULL | 수정일시 |
| deleted_at | DATETIME | NULL | 삭제일시 (Soft Delete) |

**인덱스:**
- `idx_matching_id`: matching_id에 대한 UNIQUE 인덱스
- `idx_deleted_at`: deleted_at에 대한 인덱스 (Soft Delete 조회용)

**비즈니스 규칙:**
- 하나의 매칭(`Matching`)은 하나의 채팅방만 가질 수 있음
- 매칭이 `ACCEPTED` 상태가 되면 자동으로 채팅방 생성
- 채팅방은 Soft Delete 방식으로 삭제

#### 2. chat_message 테이블

| 컬럼명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| id | BIGINT | PK, AUTO_INCREMENT | 메시지 ID |
| chat_room_id | BIGINT | FK, NOT NULL | 채팅방 ID |
| sender_id | BIGINT | FK, NOT NULL | 발신자 ID (Member) |
| content | TEXT | NOT NULL | 메시지 원문 내용 |
| language | VARCHAR(10) | NOT NULL | 메시지 언어 (KOREAN, JAPANESE) |
| translated_content | TEXT | NULL | 번역된 메시지 내용 |
| message_type | VARCHAR(20) | NOT NULL | 메시지 타입 (TEXT, IMAGE, SYSTEM) |
| is_read | BOOLEAN | NOT NULL, DEFAULT FALSE | 읽음 여부 |
| read_at | DATETIME | NULL | 읽은 시간 |
| created_at | DATETIME | NOT NULL | 생성일시 |
| archived_at | DATETIME | NULL | 아카이빙 일시 (3개월 후 S3로 이동) |
| deleted_at | DATETIME | NULL | 삭제일시 (Soft Delete) |

**인덱스:**
- `idx_chat_room_id_created_at`: (chat_room_id, created_at) 복합 인덱스 (메시지 조회 최적화)
- `idx_sender_id`: sender_id 인덱스
- `idx_is_read`: is_read 인덱스 (읽지 않은 메시지 조회용)
- `idx_archived_at`: archived_at 인덱스 (아카이빙 대상 조회용)
- `idx_created_at`: created_at 인덱스 (아카이빙 스케줄러용)

**비즈니스 규칙:**
- 메시지는 반드시 채팅방에 속해야 함
- 발신자는 채팅방의 참여자(여성 또는 남성)여야 함
- 메시지 언어는 발신자의 성별에 따라 자동 설정:
  - `JAPANESE_FEMALE` → `language = JAPANESE`
  - `KOREAN_MALE` → `language = KOREAN`
- 메시지 전송 시 상대방 언어로 자동 번역하여 `translated_content`에 저장
- 메시지 타입: TEXT(일반 텍스트), IMAGE(이미지), SYSTEM(시스템 메시지)
- 읽지 않은 메시지는 `is_read = false`로 표시
- 번역 실패 시에도 원문은 저장되며, `translated_content`는 NULL로 저장
- **메시지 보관 정책**: 
  - Hot Data: 최근 3개월 메시지는 RDS에 저장 (빠른 조회)
  - Cold Data: 3개월 이상 된 메시지는 S3로 아카이빙 (저비용 보관)
  - 아카이빙 시 `archived_at` 필드에 아카이빙 일시 기록

---

## API 명세

### REST API

#### 1. 채팅방 목록 조회

**요청**
```
GET /api/chat/rooms
Authorization: Bearer {JWT_TOKEN}
```

**인증 요구사항:**
- JWT 토큰 필수
- 토큰에서 사용자 ID 추출하여 해당 사용자의 채팅방만 조회

**응답 (200 OK)**
```json
{
  "chatRooms": [
    {
      "chatRoomId": 1,
      "matchingId": 10,
      "partner": {
        "memberId": 5,
        "name": "홍길동",
        "thumbnailImageUrl": "https://...",
        "gender": "KOREAN_MALE"
      },
      "lastMessage": {
        "messageId": 100,
        "content": "안녕하세요!",
        "translatedContent": "こんにちは！",
        "language": "KOREAN",
        "senderId": 5,
        "messageType": "TEXT",
        "createdAt": "2024-01-15T10:30:00"
      },
      "unreadCount": 3,
      "createdAt": "2024-01-15T09:00:00"
    }
  ]
}
```

**에러 응답**
- `401 Unauthorized`: 인증되지 않은 사용자 또는 만료된 토큰
- `500 Internal Server Error`: 서버 오류

**비즈니스 로직:**
- 현재 로그인한 사용자(`@LoginMember`)의 채팅방만 조회
- `chatRoom.femaleMember.id` 또는 `chatRoom.maleMember.id`와 현재 사용자 ID 일치 여부 확인

---

#### 2. 채팅방 상세 조회

**요청**
```
GET /api/chat/rooms/{chatRoomId}
Authorization: Bearer {JWT_TOKEN}
```

**응답 (200 OK)**
```json
{
  "chatRoomId": 1,
  "matchingId": 10,
  "partner": {
    "memberId": 5,
    "name": "홍길동",
    "thumbnailImageUrl": "https://...",
    "gender": "KOREAN_MALE"
  },
  "createdAt": "2024-01-15T09:00:00"
}
```

**에러 응답**
- `401 Unauthorized`: 인증되지 않은 사용자
- `403 Forbidden`: 해당 채팅방에 접근 권한 없음
- `404 Not Found`: 채팅방을 찾을 수 없음

---

#### 3. 메시지 목록 조회 (페이징)

**요청**
```
GET /api/chat/rooms/{chatRoomId}/messages?page=0&size=20&sort=createdAt,desc
Authorization: Bearer {JWT_TOKEN}
```

**Query Parameters**
- `page`: 페이지 번호 (기본값: 0)
- `size`: 페이지 크기 (기본값: 20, 최대: 100)
- `sort`: 정렬 기준 (기본값: createdAt,desc)

**응답 (200 OK)**
```json
{
  "messages": [
    {
      "messageId": 100,
      "senderId": 5,
      "senderName": "홍길동",
      "content": "안녕하세요!",
      "translatedContent": "こんにちは！",
      "language": "KOREAN",
      "messageType": "TEXT",
      "isRead": true,
      "readAt": "2024-01-15T10:31:00",
      "createdAt": "2024-01-15T10:30:00"
    },
    {
      "messageId": 99,
      "senderId": 3,
      "senderName": "나",
      "content": "はじめまして！",
      "translatedContent": "처음 뵙겠습니다!",
      "language": "JAPANESE",
      "messageType": "TEXT",
      "isRead": true,
      "readAt": "2024-01-15T10:30:30",
      "createdAt": "2024-01-15T10:30:15"
    }
  ],
  "page": {
    "number": 0,
    "size": 20,
    "totalElements": 45,
    "totalPages": 3,
    "hasNext": true,
    "hasPrevious": false
  }
}
```

**에러 응답**
- `401 Unauthorized`: 인증되지 않은 사용자
- `403 Forbidden`: 해당 채팅방에 접근 권한 없음
- `404 Not Found`: 채팅방을 찾을 수 없음

---

#### 4. 읽지 않은 메시지 개수 조회

**요청**
```
GET /api/chat/rooms/unread-count
Authorization: Bearer {JWT_TOKEN}
```

**응답 (200 OK)**
```json
{
  "totalUnreadCount": 5,
  "unreadCountByRoom": [
    {
      "chatRoomId": 1,
      "unreadCount": 3
    },
    {
      "chatRoomId": 2,
      "unreadCount": 2
    }
  ]
}
```

---

#### 5. 메시지 읽음 처리

**요청**
```
PUT /api/chat/rooms/{chatRoomId}/messages/read
Authorization: Bearer {JWT_TOKEN}
```

**응답 (200 OK)**
```json
{
  "message": "메시지 읽음 처리 완료",
  "readCount": 5
}
```

**에러 응답**
- `401 Unauthorized`: 인증되지 않은 사용자 또는 만료된 토큰
- `403 Forbidden`: 해당 채팅방에 접근 권한 없음 (채팅방 참여자가 아님)
- `404 Not Found`: 채팅방을 찾을 수 없음

**권한 검증:**
- 읽음 처리 시 현재 사용자가 채팅방의 여성 또는 남성 참여자인지 확인
- 불일치 시 `403 Forbidden` 응답

---

### WebSocket API

#### 1. WebSocket 연결

**연결 URL**
```
ws://{host}/ws/chat
```

**연결 시 인증:**
- **STOMP CONNECT 프레임에 JWT 토큰 포함** (권장)
  ```
  CONNECT
  Authorization:Bearer {JWT_TOKEN}
  ```
- 또는 Query Parameter로 전달 (개발 환경용)
  ```
  ws://{host}/ws/chat?token={JWT_TOKEN}
  ```
- 서버에서 토큰 검증 후 연결 허용/거부
- 인증 실패 시 연결 즉시 종료

**보안 고려사항:**
- 프로덕션 환경에서는 STOMP 헤더 사용 권장 (Query Parameter는 로그에 남을 수 있음)
- 토큰 만료 시 자동 재연결 로직 필요

---

#### 2. 메시지 전송

**Destination:** `/app/chat.send`

**Payload:**
```json
{
  "chatRoomId": 1,
  "content": "안녕하세요!",
  "messageType": "TEXT"
}
```

**인증 요구사항:**
- WebSocket 연결 시 JWT 토큰 검증 필수
- 메시지 전송 시 발신자 ID는 세션의 인증 정보에서 추출

**참고:** 
- 메시지 언어는 발신자의 성별에 따라 자동 설정됨
- 서버에서 자동으로 번역 처리하여 `translated_content` 생성
- 원문은 즉시 전송되고, 번역문은 비동기로 업데이트됨

**응답 (성공 시):**
- Destination: `/user/{userId}/queue/messages`
- Payload:
```json
{
  "messageId": 101,
  "chatRoomId": 1,
  "senderId": 3,
  "senderName": "나",
  "content": "안녕하세요!",
  "translatedContent": "こんにちは！",
  "language": "KOREAN",
  "messageType": "TEXT",
  "createdAt": "2024-01-15T10:35:00"
}
```

**상대방에게 전송:**
- Destination: `/user/{partnerId}/queue/messages`
- Payload: 동일한 메시지 객체

**에러 응답:**
- Destination: `/user/{userId}/queue/errors`
- Payload:
```json
{
  "error": "CHAT_ROOM_NOT_FOUND",
  "message": "채팅방을 찾을 수 없습니다."
}
```

**권한 검증:**
- 메시지 전송 시 발신자가 채팅방의 여성 또는 남성 참여자인지 확인
- 불일치 시 에러 응답 전송 및 메시지 저장하지 않음

---

#### 3. 메시지 수신

**Subscribe:** `/user/{userId}/queue/messages`

**Payload:**
```json
{
  "messageId": 101,
  "chatRoomId": 1,
  "senderId": 5,
  "senderName": "홍길동",
  "content": "안녕하세요!",
  "translatedContent": "こんにちは！",
  "language": "KOREAN",
  "messageType": "TEXT",
  "isRead": false,
  "createdAt": "2024-01-15T10:35:00"
}
```

---

#### 4. 읽음 상태 업데이트 (실시간)

**Destination:** `/app/chat.read`

**Payload:**
```json
{
  "chatRoomId": 1,
  "messageIds": [101, 102, 103]
}
```

**응답:**
- 상대방에게 읽음 상태 알림 전송
- Destination: `/user/{partnerId}/queue/read-status`
- Payload:
```json
{
  "chatRoomId": 1,
  "messageIds": [101, 102, 103],
  "readAt": "2024-01-15T10:36:00"
}
```

---

## 다국어 및 번역 기능

### 언어 Enum 정의

**파일 위치:** `src/main/java/masil/backend/modules/chat/enums/MessageLanguage.java`

```java
public enum MessageLanguage {
    KOREAN("ko", "한국어"),
    JAPANESE("ja", "日本語");
    
    private final String code;
    private final String displayName;
}
```

### 번역 서비스

**파일 위치:** `src/main/java/masil/backend/modules/chat/service/TranslationService.java`

**주요 기능:**
1. **Google Cloud Translation API**를 활용한 한국어-일본어 번역 (고속 응답 보장)
2. 비동기 번역 처리 (메시지 전송 성능 최적화)
3. 번역 캐싱 (자주 사용되는 표현 캐싱으로 지연 시간 최소화)
4. 번역 실패 시 원문 반환

**번역 로직:**
- 한국어 → 일본어: Google Cloud Translation API를 통한 번역 (평균 100~300ms)
- 일본어 → 한국어: Google Cloud Translation API를 통한 번역 (평균 100~300ms)
- 번역 캐싱: 자주 사용되는 표현은 캐시에서 즉시 반환 (<10ms)
- 번역 실패 시: 원문 그대로 저장, `translated_content = NULL`

**성능 목표:**
- 번역 API 응답 시간: 100~300ms
- 캐시 히트 시: <10ms
- 전체 메시지 전송 지연: <500ms (원문 즉시 전송으로 사용자 체감 지연 최소화)

### 메시지 언어 자동 감지

**발신자 성별 기반 언어 설정:**
- `Gender.JAPANESE_FEMALE` → `MessageLanguage.JAPANESE`
- `Gender.KOREAN_MALE` → `MessageLanguage.KOREAN`

### 번역 처리 흐름 (하이브리드 방식)

**핵심 전략: 원문 즉시 전송 + 번역문 비동기 업데이트**

```
[메시지 전송]
    ↓
[발신자 언어 감지]
    ↓
[원문 저장 (content)]
    ↓
[원문 즉시 전송] ← 사용자는 즉시 메시지 확인 가능 (지연 <50ms)
    ↓
[번역 캐시 확인]
    ├─ 캐시 히트 → 번역문 즉시 저장 및 전송 (<10ms)
    └─ 캐시 미스 → 비동기 번역 API 호출
                    ↓
                [Google Translation API 호출] (100~300ms)
                    ↓
                [번역문 저장 (translated_content)]
                    ↓
                [번역문 업데이트 전송] ← 번역 완료 후 업데이트
```

**사용자 경험:**
1. 사용자가 메시지 전송 → 즉시 원문 표시 (지연 거의 없음)
2. 번역 중 표시 (로딩 인디케이터)
3. 번역 완료 시 번역문 표시 (100~300ms 후)

**장점:**
- ✅ 사용자는 즉시 메시지 확인 가능 (원문)
- ✅ 번역 지연이 UX에 미치는 영향 최소화
- ✅ 번역 실패 시에도 원문은 표시됨
- ✅ 캐싱으로 자주 사용되는 표현은 거의 즉시 번역

---

## WebSocket 설정

### 의존성 추가

`build.gradle`에 다음 의존성 추가:

```gradle
dependencies {
    // WebSocket
    implementation 'org.springframework.boot:spring-boot-starter-websocket'
    
    // STOMP 메시징
    implementation 'org.springframework:spring-messaging'
    
    // Google Cloud Translation API (고속 번역)
    implementation 'com.google.cloud:google-cloud-translate:2.8.0'
    
    // 캐싱 (번역 결과 캐싱)
    implementation 'org.springframework.boot:spring-boot-starter-cache'
    implementation 'com.github.ben-manes.caffeine:caffeine:3.1.8'
}
```

**참고:** Spring AI는 프로필 요약 생성 등 다른 용도로 계속 사용되며, 채팅 번역에는 Google Cloud Translation API를 사용합니다.

### WebSocket 설정 클래스

**파일 위치:** `src/main/java/masil/backend/global/config/WebSocketConfig.java`

**주요 기능:**
1. STOMP 엔드포인트 설정 (`/ws/chat`)
2. 메시지 브로커 설정 (인메모리 또는 Redis)
3. JWT 기반 인증 인터셉터 설정
4. CORS 설정

### 인증 인터셉터

**파일 위치:** `src/main/java/masil/backend/modules/chat/interceptor/WebSocketAuthInterceptor.java`

**기능:**
- WebSocket 연결 시 JWT 토큰 검증 (STOMP 헤더 또는 Query Parameter에서 추출)
- `JwtProvider`를 활용한 토큰 검증
- 인증된 사용자 정보(`MemberDetails`)를 세션에 저장
- 인증 실패 시 연결 즉시 거부 및 에러 메시지 전송

**구현 예시:**
```java
@Component
@RequiredArgsConstructor
public class WebSocketAuthInterceptor implements HandshakeInterceptor {
    private final JwtProvider jwtProvider;
    
    @Override
    public boolean beforeHandshake(ServerHttpRequest request, 
                                   ServerHttpResponse response,
                                   WebSocketHandler wsHandler,
                                   Map<String, Object> attributes) {
        // STOMP 헤더 또는 Query Parameter에서 토큰 추출
        String token = extractToken(request);
        
        if (token == null || !jwtProvider.validateToken(token)) {
            response.setStatusCode(HttpStatus.UNAUTHORIZED);
            return false; // 연결 거부
        }
        
        // 인증 정보를 세션에 저장
        Authentication auth = jwtProvider.getAuthentication(token);
        attributes.put("authentication", auth);
        
        return true; // 연결 허용
    }
}
```

---

## 구현 단계

### Phase 1: 데이터베이스 및 엔티티 구현 (1일)

1. **Enum 생성**
   - `MessageType` Enum (TEXT, IMAGE, SYSTEM)
   - `MessageLanguage` Enum (KOREAN, JAPANESE)

2. **엔티티 생성**
   - `ChatRoom` 엔티티
   - `ChatMessage` 엔티티 (language, translated_content, archived_at 필드 포함)

3. **Repository 생성**
   - `ChatRoomRepository`
   - `ChatMessageRepository`

4. **매칭 서비스 수정**
   - `MatchingService.acceptMatchingByMale()` 메서드 수정
   - 매칭 수락 시 채팅방 자동 생성 로직 추가

5. **아카이빙 관련 설정**
   - `archived_at` 필드 추가
   - 아카이빙 대상 조회 쿼리 작성

---

### Phase 2: REST API 구현 (2일)

1. **DTO 생성**
   - Request DTO: `ChatRoomListRequest`, `MessageListRequest`, `SendMessageRequest`
   - Response DTO: `ChatRoomListResponse`, `ChatRoomDetailResponse`, `MessageResponse`, `UnreadCountResponse`
   - Response DTO에 `content`, `translatedContent`, `language` 필드 포함

2. **Service 구현**
   - `ChatRoomService`: 채팅방 조회, 생성 로직
   - `ChatMessageService`: 메시지 조회, 읽음 처리 로직
   - `TranslationService`: Google Cloud Translation API 연동 및 번역 로직 (비동기 처리)
   - `CacheConfig`: 번역 결과 캐싱 설정

3. **Controller 구현**
   - `ChatRoomController`: REST API 엔드포인트

4. **예외 처리**
   - `ChatException`, `ChatExceptionType` 생성
   - `ExceptionAdvice`에 채팅 예외 처리 추가

---

### Phase 3: WebSocket 구현 (3일)

1. **WebSocket 설정**
   - `WebSocketConfig` 클래스 생성
   - STOMP 엔드포인트 및 브로커 설정

2. **인증 인터셉터**
   - `WebSocketAuthInterceptor` 구현
   - JWT 토큰 검증 로직

3. **번역 서비스 구현**
   - `TranslationService` 구현
   - Google Cloud Translation API를 활용한 한국어-일본어 번역
   - 비동기 번역 처리

4. **WebSocket Controller**
   - `ChatWebSocketController` 생성
   - 메시지 전송, 읽음 처리 핸들러

5. **메시지 전송 로직**
   - 발신자 언어 자동 감지 (성별 기반)
   - 원문 메시지 저장 및 즉시 전송 (하이브리드 방식)
   - 번역 캐시 확인 (캐시 히트 시 즉시 번역문 전송)
   - 비동기 번역 처리 및 번역문 저장 (캐시 미스 시)
   - 번역 완료 후 번역문 업데이트 전송
   - 푸시 알림 연동 (번역된 메시지 포함, 번역 완료 후)

---

### Phase 4: 통합 및 테스트 (2일)

1. **매칭-채팅 연동 테스트**
   - 매칭 수락 시 채팅방 생성 확인
   - 채팅방 접근 권한 확인

2. **다국어 채팅 테스트**
   - 일본 여성의 일본어 메시지 전송 및 한국어 번역 확인
   - 한국 남성의 한국어 메시지 전송 및 일본어 번역 확인
   - 번역 실패 시나리오 처리 확인

3. **실시간 메시징 테스트**
   - 양방향 메시지 전송 확인
   - 원문 및 번역문 동시 전송 확인
   - 읽음 상태 동기화 확인

4. **성능 테스트**
   - 동시 접속자 테스트
   - 메시지 전송 성능 테스트
   - 번역 처리 비동기 성능 테스트

5. **에러 처리 테스트**
   - 잘못된 채팅방 접근
   - 인증 실패 시나리오
   - 번역 API 실패 시나리오

6. **아카이빙 테스트** (선택적)
   - 3개월 이상 된 메시지 조회 테스트
   - S3 아카이빙 프로세스 테스트
   - 아카이빙된 메시지 조회 테스트

---

## 기술 스택

### 백엔드
- **Spring Boot 3.5.5**: 웹 애플리케이션 프레임워크
- **Spring WebSocket**: 실시간 양방향 통신
- **STOMP**: WebSocket 메시징 프로토콜
- **Spring Data JPA**: 데이터베이스 접근
- **MySQL**: 관계형 데이터베이스
- **JWT**: 인증 토큰
- **Firebase Cloud Messaging**: 푸시 알림
- **Google Cloud Translation API**: 고속 한국어-일본어 자동 번역 (100~300ms)

### 아키텍처 패턴
- **RESTful API**: HTTP 기반 API
- **WebSocket**: 실시간 통신
- **Repository Pattern**: 데이터 접근 계층 분리
- **Service Layer Pattern**: 비즈니스 로직 분리

---

## 보안 고려사항

### 1. 인증 및 인가
- **JWT 토큰 검증**: 
  - REST API: `Authorization: Bearer {JWT_TOKEN}` 헤더로 전달
  - WebSocket: STOMP CONNECT 프레임의 헤더 또는 Query Parameter로 전달
  - `JwtProvider`를 통한 토큰 검증 및 만료 확인
- **채팅방 접근 권한**: 
  - 채팅방 참여자(여성 또는 남성)만 접근 가능
  - 채팅방 조회 시 `chatRoom.getFemaleMember().getId()` 또는 `chatRoom.getMaleMember().getId()`와 현재 사용자 ID 비교
  - 권한 없는 접근 시 `403 Forbidden` 응답
- **메시지 발신자 검증**: 
  - 메시지 전송 시 발신자가 채팅방 참여자인지 확인
  - `senderId`와 채팅방의 `femaleMemberId` 또는 `maleMemberId` 일치 여부 확인
  - 불일치 시 `403 Forbidden` 응답

### 2. 입력 검증
- **메시지 내용 검증**: XSS 방지를 위한 HTML 태그 제거
- **메시지 길이 제한**: 최대 1000자 제한 (원문 기준)
- **언어 검증**: 발신자 성별에 따른 언어 자동 설정 및 검증
- **번역 실패 처리**: 번역 실패 시에도 원문은 저장되도록 처리
- **파일 업로드 제한**: 이미지 파일만 허용 (향후 확장)

### 3. 데이터 보호
- **Soft Delete**: 채팅방 및 메시지 삭제 시 실제 삭제하지 않고 `deleted_at` 설정
- **개인정보 보호**: 메시지 내용 암호화 검토 (필요 시)

### 4. Rate Limiting
- **메시지 전송 제한**: 
  - 사용자당 초당 최대 10개 메시지 전송 제한
  - Redis 또는 인메모리 카운터를 활용한 구현
  - 제한 초과 시 `429 Too Many Requests` 응답
- **연결 제한**: 
  - IP당 최대 동시 WebSocket 연결 수 제한 (예: 5개)
  - 사용자당 최대 동시 연결 수 제한 (예: 3개)
  - 제한 초과 시 연결 거부
- **번역 API 호출 제한**:
  - Google Cloud Translation API 할당량 관리
  - 사용자당 분당 최대 번역 요청 수 제한
  - 캐싱을 통한 API 호출 최소화

---

## 예외 처리

### 예외 타입 정의

```java
public enum ChatExceptionType implements BaseExceptionType {
    CHAT_ROOM_NOT_FOUND(404, "채팅방을 찾을 수 없습니다."),
    CHAT_ROOM_ACCESS_DENIED(403, "해당 채팅방에 접근할 수 없습니다."),
    MESSAGE_NOT_FOUND(404, "메시지를 찾을 수 없습니다."),
    INVALID_MESSAGE_CONTENT(400, "메시지 내용이 올바르지 않습니다."),
    INVALID_MESSAGE_LANGUAGE(400, "메시지 언어가 올바르지 않습니다."),
    MESSAGE_SEND_FAILED(500, "메시지 전송에 실패했습니다."),
    TRANSLATION_FAILED(500, "메시지 번역에 실패했습니다. 원문은 저장되었습니다."),
    WEBSOCKET_AUTH_FAILED(401, "WebSocket 인증에 실패했습니다."),
    CHAT_ROOM_ALREADY_EXISTS(409, "이미 채팅방이 존재합니다.");
}
```

### 예외 처리 흐름

1. **Service Layer**: 비즈니스 로직 예외 발생
2. **ExceptionAdvice**: 전역 예외 처리
3. **클라이언트**: 에러 응답 수신 및 처리

---

## 테스트 계획

### 단위 테스트

1. **Service 테스트**
   - 채팅방 생성 로직
   - 메시지 저장 로직
   - 읽음 처리 로직
   - 권한 검증 로직

2. **Repository 테스트**
   - 채팅방 조회 쿼리
   - 메시지 페이징 쿼리
   - 읽지 않은 메시지 조회 쿼리

3. **번역 서비스 테스트**
   - Google Cloud Translation API 연동 테스트
   - 한국어 → 일본어 번역 테스트
   - 일본어 → 한국어 번역 테스트
   - 번역 캐싱 동작 테스트
   - 번역 성능 테스트 (응답 시간 측정)
   - 번역 실패 시나리오 테스트
   - 번역 API 재시도 로직 테스트
   - 비동기 번역 처리 테스트

### 통합 테스트

1. **REST API 테스트**
   - 채팅방 목록 조회
   - 메시지 목록 조회
   - 읽음 처리

2. **WebSocket 테스트**
   - 연결 및 인증 (JWT 토큰 검증)
   - 인증 실패 시나리오 (만료된 토큰, 잘못된 토큰)
   - 메시지 전송 및 수신
   - 읽음 상태 동기화
   - 채팅방 접근 권한 검증 테스트

### 시나리오 테스트

1. **매칭-채팅 연동 시나리오**
   - 매칭 수락 → 채팅방 생성 확인
   - 채팅방 접근 권한 확인

2. **다국어 메시징 시나리오**
   - 일본 여성의 일본어 메시지 전송
   - 한국 남성의 한국어 메시지 전송
   - 자동 번역 처리 확인
   - 원문 및 번역문 동시 표시 확인

3. **실시간 메시징 시나리오**
   - 양방향 메시지 전송
   - 읽지 않은 메시지 개수 업데이트
   - 푸시 알림 전송 (번역된 메시지 포함)

3. **에러 시나리오**
   - 잘못된 채팅방 접근 (권한 없는 사용자)
   - 인증 실패 (만료된 토큰, 잘못된 토큰)
   - 메시지 전송 실패
   - 번역 API 실패 및 재시도 동작 확인
   - Rate Limiting 동작 확인

---

## 다국어 채팅 상세 설계

### 언어 감지 로직

**발신자 성별 기반 언어 자동 설정:**

```java
public MessageLanguage detectLanguage(Member sender) {
    if (sender.getGender() == Gender.JAPANESE_FEMALE) {
        return MessageLanguage.JAPANESE;
    } else if (sender.getGender() == Gender.KOREAN_MALE) {
        return MessageLanguage.KOREAN;
    }
    throw new IllegalArgumentException("지원하지 않는 성별입니다.");
}
```

### 번역 처리 로직

**번역 방향 결정:**

```java
public MessageLanguage getTargetLanguage(MessageLanguage sourceLanguage) {
    if (sourceLanguage == MessageLanguage.KOREAN) {
        return MessageLanguage.JAPANESE;
    } else if (sourceLanguage == MessageLanguage.JAPANESE) {
        return MessageLanguage.KOREAN;
    }
    throw new IllegalArgumentException("지원하지 않는 언어입니다.");
}
```

### Google Cloud Translation API 설정

**인증 설정:**
1. Google Cloud 프로젝트 생성 및 Translation API 활성화
2. 서비스 계정 키 파일 생성 (`service-account-key.json`)
3. 환경 변수 설정:
   ```bash
   export GOOGLE_APPLICATION_CREDENTIALS=/path/to/service-account-key.json
   ```
4. 또는 `application.properties`에 설정:
   ```properties
   spring.cloud.gcp.credentials.location=classpath:service-account-key.json
   ```

**번역 옵션:**
- `sourceLanguage`: 원본 언어 코드 ("ko" 또는 "ja")
- `targetLanguage`: 대상 언어 코드 ("ja" 또는 "ko")
- `format`: "text" (기본값)
- Google Translation API는 자동으로 존댓말/경어를 유지하며 자연스러운 번역 제공

**비용 고려사항:**
- Google Cloud Translation API는 문자 수 기준 과금
- 번역 캐싱을 통해 비용 절감
- 무료 할당량: 월 500,000자 (번역)

### Google Cloud Translation API 연동

**번역 서비스 구현 예시:**

```java
@Service
@RequiredArgsConstructor
public class TranslationService {
    private final Translate translate;
    private final Cache<String, String> translationCache;
    
    @Async("translationTaskExecutor")
    public CompletableFuture<String> translateAsync(
            String content, 
            MessageLanguage sourceLanguage,
            MessageLanguage targetLanguage
    ) {
        String cacheKey = generateCacheKey(content, sourceLanguage, targetLanguage);
        
        // 캐시 확인
        String cached = translationCache.getIfPresent(cacheKey);
        if (cached != null) {
            return CompletableFuture.completedFuture(cached);
        }
        
        // Google Translation API 호출 (재시도 로직 포함)
        String translatedText = null;
        int maxRetries = 3;
        for (int i = 0; i < maxRetries; i++) {
            try {
                Translation translation = translate.translate(
                    content,
                    Translate.TranslateOption.sourceLanguage(sourceLanguage.getCode()),
                    Translate.TranslateOption.targetLanguage(targetLanguage.getCode())
                );
                translatedText = translation.getTranslatedText();
                break; // 성공 시 루프 종료
            } catch (Exception e) {
                log.warn("번역 API 호출 실패 (시도 {}/{}): {}", i + 1, maxRetries, e.getMessage());
                if (i == maxRetries - 1) {
                    throw new TranslationException("번역 실패: " + e.getMessage());
                }
                // 지수 백오프 재시도
                Thread.sleep((long) Math.pow(2, i) * 100);
            }
        }
        
        // 캐시 저장
        if (translatedText != null) {
            translationCache.put(cacheKey, translatedText);
        }
        
        return CompletableFuture.completedFuture(translatedText);
    }
}
```

### 번역 캐싱 전략

**캐시 설정:**

```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager("translations");
        cacheManager.setCaffeine(Caffeine.newBuilder()
            .maximumSize(10_000)           // 최대 10,000개 항목
            .expireAfterWrite(24, TimeUnit.HOURS)  // 24시간 후 만료
            .recordStats());               // 통계 수집
        return cacheManager;
    }
}
```

**캐싱 대상:**
- 자주 사용되는 인사말: "안녕하세요", "감사합니다", "죄송합니다" 등
- 일반적인 대화 표현: "네", "아니요", "좋아요" 등
- 짧은 메시지 (50자 이하) 우선 캐싱

### 메시지 전송 로직 (하이브리드 방식)

**서비스 레이어 구현:**

```java
@Service
@RequiredArgsConstructor
public class ChatMessageService {
    private final ChatMessageRepository messageRepository;
    private final TranslationService translationService;
    private final WebSocketMessagingTemplate messagingTemplate;
    
    @Transactional
    public ChatMessage sendMessage(SendMessageRequest request, Long senderId) {
        // 1. 언어 감지
        Member sender = memberService.findById(senderId);
        MessageLanguage language = detectLanguage(sender);
        
        // 2. 원문 메시지 저장
        ChatMessage message = ChatMessage.builder()
            .chatRoomId(request.getChatRoomId())
            .senderId(senderId)
            .content(request.getContent())
            .language(language)
            .messageType(MessageType.TEXT)
            .build();
        message = messageRepository.save(message);
        
        // 3. 원문 즉시 전송 (사용자는 즉시 메시지 확인)
        sendMessageToPartner(message, false); // translatedContent = null
        
        // 4. 비동기 번역 처리
        translateAndUpdateAsync(message);
        
        return message;
    }
    
    @Async("translationTaskExecutor")
    private void translateAndUpdateAsync(ChatMessage message) {
        try {
            ChatRoom chatRoom = chatRoomRepository.findById(message.getChatRoomId())
                .orElseThrow();
            Member partner = getPartner(chatRoom, message.getSenderId());
            MessageLanguage targetLanguage = detectLanguage(partner);
            
            // 번역 수행 (타임아웃 설정: 최대 5초 대기)
            String translated = translationService.translateAsync(
                message.getContent(),
                message.getLanguage(),
                targetLanguage
            ).get(5, TimeUnit.SECONDS); // 비동기 완료 대기 (타임아웃 5초)
            
            // 번역문 저장 및 업데이트 전송
            message.updateTranslatedContent(translated);
            messageRepository.save(message);
            sendMessageToPartner(message, true); // 번역문 포함 업데이트
            
        } catch (TimeoutException e) {
            log.error("번역 타임아웃: messageId={}", message.getId(), e);
            // 타임아웃 시에도 원문은 이미 전송됨
        } catch (Exception e) {
            log.error("번역 실패: messageId={}", message.getId(), e);
            // 번역 실패해도 원문은 이미 전송됨
            // 필요 시 재시도 큐에 추가하거나 관리자에게 알림
        }
    }
}
```

### 클라이언트 표시 로직

**메시지 표시 규칙:**
- 발신자가 자신인 경우: 원문만 표시
- 발신자가 상대방인 경우:
  - 번역문이 있으면 번역문을 주로 표시
  - 번역문이 없으면 원문 표시 + 번역 중 인디케이터
  - 번역 완료 시 번역문으로 업데이트
- 원문 보기 토글 기능 (향후 확장)
- 번역 실패 시: 원문만 표시

**클라이언트 메시지 수신 예시:**

```json
// 첫 전송 (원문만)
{
  "messageId": 101,
  "chatRoomId": 1,
  "senderId": 5,
  "senderName": "홍길동",
  "content": "안녕하세요!",
  "translatedContent": null,
  "language": "KOREAN",
  "messageType": "TEXT",
  "isTranslating": true,
  "isRead": false,
  "createdAt": "2024-01-15T10:35:00"
}

// 번역 완료 후 업데이트 (WebSocket을 통한 업데이트)
{
  "messageId": 101,
  "chatRoomId": 1,
  "senderId": 5,
  "senderName": "홍길동",
  "content": "안녕하세요!",
  "translatedContent": "こんにちは！",
  "language": "KOREAN",
  "messageType": "TEXT",
  "isTranslating": false,
  "isRead": false,
  "createdAt": "2024-01-15T10:35:00"
}
```

**클라이언트 처리 로직:**
- `isTranslating: true`일 때 번역 중 인디케이터 표시
- `translatedContent`가 업데이트되면 번역문으로 교체
- 번역 실패 시 원문만 표시

---

## 메시지 보관 정책 및 비용 분석

### 메시지 보관 정책

#### Hot Data (RDS 저장)
- **보관 기간**: 최근 3개월
- **저장 위치**: MySQL RDS
- **용도**: 빠른 조회 및 실시간 채팅
- **특징**: 
  - 인덱싱된 빠른 조회
  - 실시간 메시지 목록 조회
  - 읽지 않은 메시지 관리

#### Cold Data (S3 아카이빙)
- **보관 기간**: 3개월 이상
- **저장 위치**: AWS S3 (압축 저장)
- **용도**: 장기 보관 및 감사
- **특징**:
  - 저비용 보관 (S3 Standard-IA 또는 Glacier)
  - 압축 저장으로 저장 공간 절감
  - 필요 시 복원 가능

#### 아카이빙 프로세스

**스케줄러 설정:**
```java
@Scheduled(cron = "0 0 3 * * ?") // 매일 새벽 3시 실행
public void archiveOldMessages() {
    LocalDateTime threeMonthsAgo = LocalDateTime.now().minusMonths(3);
    
    // 3개월 이상 된 메시지 조회
    List<ChatMessage> oldMessages = messageRepository
        .findByCreatedAtBeforeAndArchivedAtIsNull(threeMonthsAgo);
    
    // S3로 아카이빙
    for (ChatMessage message : oldMessages) {
        archiveToS3(message);
        message.setArchivedAt(LocalDateTime.now());
        messageRepository.save(message);
    }
}
```

**아카이빙 파일 형식:**
- 파일명: `chat-messages-{chatRoomId}-{year}-{month}.json.gz`
- 형식: JSON Lines (압축)
- 저장 경로: `s3://bucket-name/archived-chat/{year}/{month}/`

### 예상 비용 분석

#### 가정 조건
- **활성 사용자**: 100명
- **평균 채팅방 수**: 사용자당 2개
- **일평균 메시지 수**: 채팅방당 30개
- **메시지 평균 크기**: 
  - 원문: 50자 (100 bytes)
  - 번역문: 50자 (100 bytes)
  - 메타데이터: 200 bytes
  - **총 메시지 크기**: 약 400 bytes

#### 월간 메시지 생성량 계산

```
총 채팅방 수 = 100명 × 2개 = 200개
일일 메시지 수 = 200개 × 30개 = 6,000개
월간 메시지 수 = 6,000개 × 30일 = 180,000개
```

#### RDS 저장 비용 (Hot Data - 3개월)

**3개월간 메시지 수:**
```
3개월 메시지 수 = 180,000개 × 3 = 540,000개
```

**저장 공간 계산:**
```
메시지당 크기 = 400 bytes
3개월 총 크기 = 540,000개 × 400 bytes = 216,000,000 bytes ≈ 206 MB
인덱스 오버헤드 (약 30%) = 206 MB × 1.3 ≈ 268 MB
```

**RDS 비용 (MySQL db.t3.micro 기준):**
- 인스턴스: $15/월 (고정)
- 스토리지: $0.115/GB/월
- 3개월 Hot Data 스토리지: 0.268 GB × $0.115 = **$0.03/월**
- **총 RDS 비용: 약 $15.03/월**

#### S3 아카이빙 비용 (Cold Data)

**연간 메시지 수:**
```
연간 메시지 수 = 180,000개 × 12 = 2,160,000개
```

**S3 저장 공간 계산:**
```
메시지당 크기 (압축 후) = 200 bytes (50% 압축률)
연간 총 크기 = 2,160,000개 × 200 bytes = 432,000,000 bytes ≈ 412 MB
```

**S3 비용 (Standard-IA 스토리지):**
- 스토리지: $0.0125/GB/월
- 연간 Cold Data 스토리지: 0.412 GB × $0.0125 = **$0.005/월**
- 요청 비용: PUT 요청 $0.01/1,000건
  - 월간 아카이빙 요청: 180,000건 = **$1.80/월**
- **총 S3 비용: 약 $1.81/월**

#### Google Cloud Translation API 비용

**월간 번역 문자 수:**
```
월간 메시지 수 = 180,000개
메시지당 평균 문자 수 = 50자
월간 총 문자 수 = 180,000개 × 50자 = 9,000,000자
```

**번역 API 비용:**
- 무료 할당량: 월 500,000자
- 유료 구간: (9,000,000 - 500,000) × $20/1,000,000자
- 유료 비용: 8,500,000자 × $20/1,000,000 = **$170/월**
- **총 번역 API 비용: $170/월**

**번역 캐싱 효과 (캐시 히트율 30% 가정):**
- 캐시 히트로 인한 절감: 9,000,000자 × 30% = 2,700,000자
- 실제 번역 문자 수: 9,000,000 - 2,700,000 = 6,300,000자
- 유료 구간: (6,300,000 - 500,000) × $20/1,000,000 = **$116/월**
- **캐싱 적용 후 번역 API 비용: $116/월**

#### 총 예상 비용 (월간)

| 항목 | 비용 | 비고 |
|------|------|------|
| RDS (MySQL) | $15.03 | 인스턴스 + Hot Data 스토리지 (3개월) |
| S3 아카이빙 | $1.81 | Cold Data 스토리지 + 요청 비용 |
| Google Translation API | $116 | 번역 API (캐싱 적용 시) |
| **총계** | **$132.84/월** | |

#### 비용 최적화 전략

1. **번역 캐싱 강화**
   - 캐시 히트율 30% → 50% 목표
   - 예상 절감: $54/월 → **$82/월**

2. **S3 Glacier 사용 (1년 이상 데이터)**
   - Glacier 스토리지: $0.004/GB/월
   - 예상 절감: $0.005/월 → $0.002/월

3. **메시지 압축률 향상**
   - 현재 50% → 70% 목표
   - S3 저장 공간 절감

4. **RDS 인스턴스 최적화**
   - 사용자 증가 시 스케일 업 필요
   - 예상: 500명 기준 db.t3.small ($30/월)

#### 사용자 수별 예상 비용

| 사용자 수 | 월간 메시지 | RDS 비용 | S3 비용 | 번역 API | 총 비용 |
|----------|------------|---------|---------|---------|---------|
| 100명 | 180,000개 | $15.03 | $1.81 | $116 | **$132.84** |
| 500명 | 900,000개 | $30 | $9.05 | $580 | **$619.05** |
| 1,000명 | 1,800,000개 | $60 | $18.10 | $1,160 | **$1,238.10** |

**참고:**
- 사용자 수 증가에 따라 RDS 인스턴스 스케일 업 필요
- 번역 API 비용은 메시지 수에 비례하여 증가
- 캐싱 효과로 실제 비용은 더 낮을 수 있음

### 아카이빙 구현 계획

#### Phase 1: 기본 아카이빙 (즉시 구현)
- 3개월 이상 된 메시지 조회 쿼리
- S3 업로드 기능
- `archived_at` 필드 업데이트

#### Phase 2: 스케줄러 구현 (1주일 내)
- Spring Scheduler를 통한 자동 아카이빙
- 매일 새벽 3시 실행
- 에러 처리 및 재시도 로직

#### Phase 3: 아카이빙 조회 API (2주일 내)
- 아카이빙된 메시지 조회 API
- S3에서 복원 및 조회
- 페이징 지원

---

## 추가 고려사항

### 1. 확장성
- **메시지 브로커**: 인메모리 브로커 → Redis 기반 브로커로 전환 고려
- **채팅방 수 제한**: 사용자당 최대 채팅방 수 제한 (예: 10개)
- **메시지 보관 정책**: 
  - Hot Data: 최근 3개월 메시지는 RDS에 저장
  - Cold Data: 3개월 이상 된 메시지는 S3로 자동 아카이빙
  - 아카이빙 스케줄러: 매일 새벽 3시 실행
- **비용 최적화**: 번역 캐싱 강화 및 S3 Glacier 활용

### 2. 성능 최적화
- **메시지 페이징**: 커서 기반 페이징 고려
- **읽지 않은 메시지 캐싱**: Redis 캐싱 고려
- **인덱스 최적화**: 데이터베이스 인덱스 튜닝
- **번역 캐싱**: Caffeine Cache를 통한 번역 결과 캐싱 (자주 사용되는 표현)
- **하이브리드 전송**: 원문 즉시 전송으로 사용자 체감 지연 최소화
- **비동기 번역 처리**: 번역 API 호출을 비동기로 처리하여 메시지 전송 블로킹 방지
- **번역 API 재시도**: 지수 백오프를 통한 재시도 로직으로 안정성 향상

### 3. 기능 확장 (향후)
- **이미지 전송**: 이미지 파일 업로드 및 전송
- **읽음 확인**: 상대방이 메시지를 읽었는지 실시간 확인
- **메시지 검색**: 채팅방 내 메시지 검색 기능 (원문 및 번역문 모두 검색)
- **채팅방 나가기**: 채팅방 나가기 기능
- **번역 품질 개선**: Google Translation API 모델 선택 및 컨텍스트 고려
- **번역 캐싱 확장**: Redis를 통한 분산 캐싱 (여러 서버 인스턴스 간 캐시 공유)
- **원문/번역문 토글**: 사용자가 원문과 번역문을 선택적으로 볼 수 있는 기능
- **번역 품질 피드백**: 사용자가 번역 품질에 대한 피드백 제공 기능

---

## 일정 요약

| Phase | 작업 내용 | 예상 기간 |
|-------|----------|----------|
| Phase 1 | 데이터베이스 및 엔티티 구현 (언어 필드 포함) | 1일 |
| Phase 2 | REST API 구현 (다국어 응답 포함) | 2일 |
| Phase 3 | WebSocket 구현 + 번역 서비스 | 3일 |
| Phase 4 | 통합 및 테스트 (다국어 테스트 포함) | 2일 |
| **총계** | | **8일** |

---

## 결론

본 계획서는 매칭 성공 시 채팅방을 자동으로 생성하고 실시간 채팅 기능을 제공하는 것을 목표로 합니다. 단계별로 구현을 진행하여 안정적이고 확장 가능한 채팅 시스템을 구축할 수 있습니다.

### 주요 특징
- ✅ 매칭 성공 시 자동 채팅방 생성
- ✅ 실시간 양방향 메시징
- ✅ **다국어 채팅 지원** (한국어/일본어)
- ✅ **고속 자동 번역 기능** (Google Cloud Translation API 기반, 100~300ms)
- ✅ 원문 및 번역문 동시 저장 및 표시
- ✅ 읽지 않은 메시지 개수 관리
- ✅ JWT 기반 보안 인증
- ✅ 푸시 알림 연동 (번역된 메시지 포함)
- ✅ 확장 가능한 아키텍처

### 다음 단계
1. Phase 1부터 순차적으로 구현 시작
2. 각 Phase 완료 후 코드 리뷰 및 테스트
3. 프로덕션 배포 전 성능 테스트 및 보안 점검
